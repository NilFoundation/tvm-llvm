	.internal-alias :main_external,     -1
	.internal-alias :main_internal,     0
	.internal-alias :general_purpose,   1
	.internal-alias :authenticate,      2
	.internal-alias :parse_msg,         3

	.internal-alias :init_fstack,       4
        .internal-alias :term_fstack,       10
	.internal-alias :enter,             5
	.internal-alias :leave,             6
	.internal-alias :load,              7
	.internal-alias :store,             8
	.internal-alias :frameidx,          9

	.internal-alias :load_bp,           11
	.internal-alias :store_bp,          12
	.internal-alias :load_work_slice,  13
	.internal-alias :store_work_slice, 14

    .selector
    ; s0 - func_id
    ; s1.. - other data
    SETCP0
    PUSHREFSLICE        ; dictionary of methods in first reference
    OVER
    NEQINT 1
    PUSHCONT {          ; if func_id negative or zero - direct call to method
        PUSHINT 32
        DICTIGETJMP     ; execute method and return
    }
    PUSHCONT {          ; get dictionary with methods
        PUSHINT 32
        DICTIGET
        THROWIFNOT 52   ; no dictionary of methods
        PUSHINT 32
        DICTUGETJMP     ; execute method and return
        THROW 51
    }
    IFELSE

    .internal   :authenticate
    ;ref0 must contains auth dictionary
    ;args: 
    ;   s0 - body slice
    ;ret: 
    ;   s0 - body slice (modified: without ref0)
    ;throws exception if ABI version is unsupported
    ;throws exception if auth flag is not found in authentication dictionary.
    ;throws exception if signature is invalid

    DUP
    PUSHINT 40          ;preload ABI ver and func_id in separate slice
    PLDSLICEX
    LDU 8               ;load ABI version
    LDU 32              ;load func id
    ENDS
    SWAP
    THROWIF 55
    PUSHREFSLICE
    DUP
    SEMPTY
    IFRET
    PUSHINT 32          ;key len in auth dictionary
    DICTUGET            ;load method's flag 
    THROWIFNOT 41       ;not found exception
    PLDU 1
    PUSHCONT {
        DUP
        SREMPTY         ;body must have reference, if not - throw exception
        THROWIF 40      ;access denied exception
        LDREFRTOS       ;detach signature slice
        OVER
        HASHSU
        SWAP    
        PUSHROOT        ;load persistent data
        CTOS            
        LDU 256         ;load public key
        DROP            ;drop remaining data slice
        CHKSIGNU
        THROWIFNOT 40   ;access denied exception
    }
    IF

    .internal   :main_external
    ; s0 - msg body: slice
    ; s1 - msg: cell
    ; s2 - gram balance of msg: int
    ; s3 - gram balance of contract: int

    ;call signature checker (can throw exception if signature is invalid)
    CALL $:authenticate$ ;assume that function returns nothing
    
    ;call msg parser
    PUSH s1     ;push msg cell on top
    CALL $:parse_msg$    ;assume thar parser returns slice - dictionary with msg fields
    
    ; Initialize C stack
    CALL $:init_fstack$

    SWAP
    ;parse ABI version (1 byte) and load function id (4 bytes)
    LDU 8       ;load ABI version
    SWAP  
    THROWIF 55  ; only version 0 is supported now
    LDU 32      ;load func id
    SWAP
    CALL 1      ;public method call
    JMP $:term_fstack$

    .internal   :main_internal
    RET         ;contract ignores internal msgs by default 

    .internal   :parse_msg
    CTOS        ;TODO: use parser from contract_api library


; Functions for C
; -100000: BP pointer
    .internal   :load_bp
    PUSHINT -100000
    CALL $:load$

    .internal   :store_bp
    PUSHINT -100000
    XCHG s0, s1
    CALL $:store$

    .internal   :init_fstack
    ; Initialize stack
    ; At initialization: 
    ; 1) C4 contains persistent_data
    ; 2) C5 contains ref to smart_contract_info
    ; 
    ; Result:
    ; 1) C5 contains dictionary with stack
    ; 2) At key -99999 dict. C5 contains ref to smart_contract_info
    PUSH c5
    CTOS                       ; ( slice_with_smart_contract_info_ref )
    LDREF                      ; ( smart_contract_info_slice slice_with_smart_contract_info_ref )
    ENDS                       ; ( smart_contract_info_slice )
    CTOS
    PUSHINT -99999             ; ( smart_contract_info_slice addr )
    NEWDICT                    ; ( smart_contract_info_slice addr dict_slice )
    PUSHINT 64                 ; ( smart_contract_info_slice addr dict-slice key-width )
    DICTISET                   ; ( dict-slice' )
    NEWC STSLICE ENDC          ; ( dict_cell )
    POP c5      

    PUSHINT 1000000000         ; ( new_stack_base_pointer )
    CALL $:store_bp$           ; ( )
    RET

    .internal	:term_fstack
    ; Terminate stack -- copy values back from C5
    ; 
    ; Before termination: 
    ; 1) C5 contains dictionary with stack
    ; 2) At key -99999 dict. C5 contains ref to smart_contract_info
    ; 
    ; Result:
    ; 1) C5 ref to smart_contract_info; dict. is dropped

    PUSHINT -99999             ; ( addr )
    PUSH c5                    ; ( addr dict-cell )
    CTOS                       ; ( addr dict-slice )
    PUSHINT 64                 ; ( addr dict-slice key-width )
    DICTIGET                   ; ( addr dict-slice key-width -- value-slice flag)
    THROWIFNOT 60              ; ( smart-contract-info-ref )
    NEWC STSLICE ENDC
    NEWC STREF ENDC            ; ( cell-with-smart-contract-info-ref )
    POP c5                     ; reset c5 value back to smart_contract_info

    .internal   :enter
    CALL $:load_bp$
    SWAP
    SUB
    CALL $:store_bp$

    .internal   :leave
    CALL $:load_bp$
    ADD
    CALL $:store_bp$

    .internal   :load
    PUSH c5
    CTOS
    PUSHINT 64
    DICTIGET ; (addr dict-slice key-width -- value-slice flag)

    THROWIFNOT 60
    LDI 256 ENDS

    .internal   :store
    ; (addr val -- )
    NEWC STI 256 ENDC
    CTOS     ; (addr val-slice)
    XCHG s0, s1

    PUSH c5
    CTOS     ; (val-slice addr dict-slice)
    PUSHINT 64
    DICTISET ; (val-slice addr dict-slice key-width -- dict-slice')
    NEWC STSLICE ENDC
    POP c5

    .internal   :frameidx
    CALL $:load_bp$
    ;PUSHINT 10 ; arbitrary value
    ADD

    ; User-level functions and constants
    ;
    ; Get builder cell (internal call)
    ; ( -- builder-cell )
    ;
    .internal	:load_work_slice
    PUSHINT -99998            ; ( builder-cell-address )
    PUSH c5
    CTOS
    PUSHINT 64
    DICTIGET               ; ( addr dict-slice key-width -- slice_with_smart_contract_info_ref flag )
    THROWIFNOT 60

    ;
    ; Set builder cell (internal call)
    ; ( builder-cell -- )
    ;
    .internal	:store_work_slice
    PUSHINT -99998            ; ( cell addr )
    PUSH c5
    CTOS                   ; ( cell addr dict-slice)
    PUSHINT 64
    DICTISET               ; ( cell addr dict-slice key-width -- dict-slice' )
    NEWC STSLICE ENDC
    POP c5                 ; ( )

    ; smart contract info --- get it from stack
    .globl	tonstdlib_get_smart_contract_info
    .type	tonstdlib_get_smart_contract_info,@function
tonstdlib_get_smart_contract_info:
    PUSHINT -99999            ; address of slice with smart_contract_info_ref
    PUSH c5
    CTOS
    PUSHINT 64
    DICTIGET               ; ( addr dict-slice key-width -- smart_contract_info_cell flag )
    THROWIFNOT 60          ; ( smart_contract_info_cell )

    ;
    ; Initialize work cell
    ; ( -- )
    ;
    .globl	tonstdlib_create_empty_work_slice
    .type	tonstdlib_create_empty_work_slice,@function
tonstdlib_create_empty_work_slice:
    NEWC ENDC CTOS         ; create empty cell: ( empty_cell )
    JMP $:store_work_slice$

    ;
    ; Append work cell with an integer:
    ; ( int-value width -- )
    ;
    .globl	tonstdlib_work_slice_store_int
    .type	tonstdlib_work_slice_store_int,@function
tonstdlib_work_slice_store_int:
    CALL $:load_work_slice$    ; ( int-value width work-slice )
    NEWC STSLICE               ; ( uint-value width work-cell-builder )
    SWAP                       ; ( uint-value work-cell-builder width )
    STIX                       ; ( work-cell-builder' )
    ENDC                       ; ( work-cell )
    CTOS                       ; ( work-slice )
    JMP $:store_work_slice$

    ;
    ; Append work cell with an unsigned integer:
    ; ( uint-value width -- )
    ;
    .globl	tonstdlib_work_slice_store_uint
    .type	tonstdlib_work_slice_store_uint,@function
tonstdlib_work_slice_store_uint:
    CALL $:load_work_slice$    ; ( uint-value width work-slice )
    NEWC STSLICE               ; ( uint-value width work-cell-builder )
    SWAP                       ; ( uint-value work-cell-builder width )
    STUX                       ; ( work-cell-builder )
    ENDC                       ; ( work-cell )
    CTOS                       ; ( work-slice )
    JMP $:store_work_slice$

    ;
    ; Load integer from work cell:
    ; ( width -- int-value )
    ;
    .globl	tonstdlib_work_slice_load_int
    .type	tonstdlib_work_slice_load_int,@function
tonstdlib_work_slice_load_int:
    CALL $:load_work_slice$    ; ( width work-slice )
    SWAP                       ; ( work-slice width )
    LDIX                       ; ( int-value work-slice' )
    JMP $:store_work_slice$

    ;
    ; Load unsigned from work cell:
    ; ( width -- uint-value )
    ;
    .globl	tonstdlib_work_slice_load_uint
    .type	tonstdlib_work_slice_load_uint,@function
tonstdlib_work_slice_load_uint:
    CALL $:load_work_slice$    ; ( width work-slice )
    SWAP                       ; ( work-slice width )
    LDUX                       ; ( int-value work-slice' )
    JMP $:store_work_slice$

    ;
    ; Get builder cell 
    ; ( -- builder-cell )
    ;
    .globl	tonstdlib_get_work_slice
    .type	tonstdlib_get_work_slice,@function
tonstdlib_get_work_slice:
    JMP $:load_work_slice$

    ;
    ; Send raw message: takes message from work slice
    ; ( flags -- )
    ;
    .globl	tonstdlib_send_work_slice_as_rawmsg
    .type	tonstdlib_send_work_slice_as_rawmsg,@function
tonstdlib_send_work_slice_as_rawmsg:
    CALL $:load_work_slice$
    NEWC STSLICE ENDC
    SWAP
    SENDRAWMSG
